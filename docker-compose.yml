version: "3.7"

services:
  caddy:
    container_name: caddy
    build:
      context: ${DOCKERDIR}
      dockerfile: caddy.dockerfile #Custom build which uses duckdns

    depends_on:
      - jellyfin
      - uptime-kuma


    external_links:
      - crowdsec:crowdsec
      - jellyfin:jellyfin
      - uptime_kuma:uptime_kuma

    networks:
        - web
        - caddy-net
        - htpc-net

    ports:
        - ${PORT_CADDY_HTTP}:80
        - ${PORT_CADDY_HTTPS}:443

    environment:
      LOG_FILE: ${LOGDIR}/caddy/access.log
      DOMAIN: ${DOMAIN}
      EMAIL: ${EMAIL_ADMIN}
      DUCKDNS_API_TOKEN: ${DUCKDNS_TOKEN}
      
      BOUNCER_CADDY_TOKEN: ${BOUNCER_CADDY_TOKEN}
      PORT_CROWDSEC_API: ${PORT_CROWDSEC_API}

      PORT_HTPC_HTTP: ${PORT_HTPC_HTTP}
      PORT_UPKUMA: ${PORT_UPKUMA}

    volumes:
      - ${STATICONFIGDIR}/caddy/Caddyfile:/etc/caddy/Caddyfile # Required. Needs to be an extension-less file NOT a directory
      - ${CONFIGDIR}:/data # Optional, house for certs. Caddy adds its own /caddy/ directory
      - ${CONFIGDIR}:/config # Optional, JSON Config files. Caddy adds its own /caddy/ directory
      - ${LOGDIR}/caddy:/server/logs/caddy ## check for /access.log

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 64M
    healthcheck:
      test: ["CMD", "caddy", "version"]
    restart: unless-stopped
  
  crowdsec:
    container_name: crowdsec
    image: crowdsecurity/crowdsec:v1.4.1

    depends_on:
      - caddy
      - socky_proxy
    
    networks:
      - caddy-net # provides access for the reverse proxy
      - socky_proxy-net

    ports:
      - ${PORT_CROWDSEC_API}:8080 # exposes a REST API for bouncers, cscli and communication between crowdsec agent and local api
      - ${PORT_CROWDSEC_METRICS}:6060 #exposes prometheus metrics on /metrics and pprof debugging metrics on /debug

    environment:
      TZ: ${TZ}
      GID: ${PGID}
      COLLECTIONS: "crowdsecurity/linux crowdsecurity/caddy crowdsecurity/linux-lpe timokoessler/uptime-kuma"
      DOCKER_HOST: tcp://socky_proxy:${PORT_SOCKY_PROXY} # redirects socket to the proxy. Needed for the config.yaml direction to scan other docker containers

    volumes:
      - ${STATICONFIGDIR}/crowdsec/acquis.yaml:/etc/crowdsec/acquis.yaml
      - crowdsec-config:/etc/crowdsec/
      - crowdsec-db:/var/lib/crowdsec/data/
    #  - ${CONFIGDIR}/crowdsec:/etc/crowdsec/ # This is my preferred way to get things working, but currently doesn't work

      ## Log Files
      - ${LOGDIR}/caddy:/var/log/caddy:ro ## check https://hub.crowdsec.net/author/crowdsecurity/configurations/caddy-logs
      - /var/log/auth.log:/logs/auth.log:ro
      - /var/log/syslog.log:/logs/syslog.log:ro
      
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    restart: always

  heimdall:
    container_name: heimdall
    image: ghcr.io/linuxserver/heimdall
    
    ports:
      - ${PORT_DASH_HTTP}:80
      - ${PORT_DASH_HTTPS}:443

    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}
    volumes:
      - ${CONFIGDIR}/heimdall:/config
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    restart: unless-stopped

  uptime-kuma:
    container_name: uptime_kuma
    image: louislam/uptime-kuma
    
    networks:
      - caddy-net # provides access for the reverse proxy
    
    ports:
      - ${PORT_UPKUMA}:3001
    
    volumes:
      - ${CONFIGDIR}/uptime-kuma:/app/data
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    restart: always

####################
# System Information
####################

  dozzle:
    container_name: dozzle
    image: amir20/dozzle:latest

    networks:
      - socky_proxy-net

    ports:
      - ${PORT_DOZZLE}:8080

    environment:
      DOCKER_HOST: tcp://socky_proxy:${PORT_SOCKY_PROXY} # redirects socket to the proxy
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 64M
    restart: always

  lazydocker:
    container_name: lazydocker
    image: lazyteam/lazydocker

    networks:
      - socky_proxy-net
    
    environment:
      DOCKER_HOST: tcp://socky_proxy:${PORT_SOCKY_PROXY} # redirects socket to the proxy

    stdin_open: true
    tty: true

    volumes:
      - ${CONFIGDIR}/lazydocker:/.config/jesseduffield/lazydocker

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 64M
    restart: always

####################
# Media
####################

  jellyfin:
    container_name: jellyfin
    image: jellyfin/jellyfin

    user: ${PUID}:${PGID}
    group_add:
      - ${GID_HARDWAREACC} # gid of your `render` group

    networks:
      - htpc-net
      - caddy-net # provides access for the reverse proxy
    
    ports:
      - ${PORT_HTPC_HTTP}:8096 #HTTP webUI
      - ${PORT_HTPC_HTTPS}:8920 #HTTPS webUI
      - ${PORT_HTPC_LOCAL}:7359/udp #optional. Allows clients to discover Jellyfin on the local network.
      - ${PORT_HTPC_DLNA}:1900/udp #optional. Service discovery used by DNLA and clients.

    environment:
      TZ: ${TZ}
      JELLYFIN_PublishedServerUrl: ${JELLYFIN_URL} #optional. The Server URL to publish in udp Auto Discovery response.

    devices:
      - /dev/dri/renderD128:/dev/dri/renderD128 # VAAPI
      - /dev/dri/card0:/dev/dri/card0

    volumes:
      - ${CONFIGDIR}/jellyfin:/config
      - ${CACHEDIR}/jellyfin:/cache
      - ${MEDIADIR}:/media:ro
    
    #deploy:
    #  resources:
    #    limits:
    #      cpus: '2'
    #      memory: 1024M
    restart: unless-stopped
  
  qbittorrent:
    container_name: qbittorrent
    image: linuxserver/qbittorrent

    depends_on:
      - protonvpn

    network_mode: service:protonvpn # ONLY provide network config in the protonvpn container

    environment:
        PUID: ${PUID}
        PGID: ${PGID}
        TZ: ${TZ}
        UMASK_SET: 022
        WEBUI_PORT: ${PORT_TORRENT_UI}

    volumes:
        - ${CONFIGDIR}/qbt:/config
        - ${DOWNLOADDIR}:/data/downloads
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    restart: unless-stopped

  prowlarr:
    container_name: prowlarr
    image: lscr.io/linuxserver/prowlarr:develop

    depends_on:
      - protonvpn
      - qbittorrent

    network_mode: service:protonvpn # ONLY provide network config in the protonvpn container

    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}

    volumes:
      - ${CONFIGDIR}/prowlarr:/config

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    restart: unless-stopped
    
  
  radarr:
    container_name: radarr
    image: lscr.io/linuxserver/radarr:latest
    
    depends_on:
      - protonvpn
      - prowlarr
      - qbittorrent

    network_mode: service:protonvpn # ONLY provide network config in the protonvpn container

    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}

    volumes:
        - /etc/localtime:/etc/localtime:ro
        - ${CONFIGDIR}/radarr3:/config
        - ${DATADIR}:/data
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 256M
    restart: unless-stopped

  sonarr:
    container_name: sonarr
    image: lscr.io/linuxserver/sonarr:3.0.9

    depends_on:
      - protonvpn
      - prowlarr
      - qbittorrent

    network_mode: service:protonvpn # ONLY provide network config in the protonvpn container

    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}

    volumes:
        - /etc/localtime:/etc/localtime:ro
        - ${CONFIGDIR}/sonarr:/config
        - ${DATADIR}:/data
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 256M
    restart: unless-stopped


####################
# Back End Services
####################

  duckdns:
    container_name: duckdns
    image: ghcr.io/linuxserver/duckdns

    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}
      SUBDOMAINS: ${DUCKDNS_SUBDOMAINLIST}
      TOKEN: ${DUCKDNS_TOKEN}
      LOG_FILE: ${LOGDIR}/duckdns.log #optional

    volumes:
      - ${CONFIGDIR}/duckdns:/config #optional

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 32M
    restart: unless-stopped

  protonvpn:
    container_name: protonvpn
    image: lscr.io/linuxserver/wireguard:latest
    
    environment:
      PUID: ${PUID}
      PGID: ${PGID}
      TZ: ${TZ}
    
    networks:
      - peer2peer
      - vpn

    ports:
      - ${PORT_WIREGUARD_OUTBOUND}:51820/udp
      - ${PORT_TORRENT_UI}:${PORT_TORRENT_UI} #default 8080
      - ${PORT_PROWLARR_UI}:9696
      - ${PORT_LIDARR_UI}:8686
      - ${PORT_RADARR_UI}:7878
      - ${PORT_SONARR_UI}:8989

    volumes:
      - ${CONFIGDIR}/wireguard:/config
      - /lib/modules:/lib/modules:ro

    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1

    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 64M
    restart: unless-stopped

  socky_proxy:
    container_name: socky_proxy
    image: ghcr.io/tecnativa/docker-socket-proxy:0.1 # A security-enhanced proxy for the Docker Socket.

    privileged: true
  
    networks:
      - socky_proxy-net

    ports:
      - ${PORT_SOCKY_PROXY}:2375

    environment:
      # Variables match the URL prefix (i.e. AUTH blocks access to /auth/* parts of the API, etc).
      #   0 - revoke access
      #   1 - grant access
      CONTAINERS: 1 # crowdsec
      INFO: 1 # crowdsec

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 32M

    restart: always

####################
# Docker Environment
####################

volumes:
  crowdsec-config:
  crowdsec-db:

networks:
  web:
    name: web
    external: true
  htpc-net:
    name: htpc-net
  caddy-net:
    name: caddy-net
  socky_proxy-net:
    name: socky_proxy-net
  peer2peer:
    name: peer2peer
  vpn:
    name: vpn
    internal: true
